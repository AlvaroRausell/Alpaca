4CCS1ELA - Elementary Logic with Applications
Programming with Logic

Sanjay Modgil
sanjay.modgil@kcl.ac.uk
Office hours 11-1 on Thursdays
Room (N)7.08 Bush House

Outline
  Recap on Lecture 2
  Definite Clause Programming : Formal definition
  Definite Clause Programming +

Control Procedures
Negation as Failure
=> Predicate Logic Programming
  Recursion

Recap on Lecture 2
  Any first order formula α can be transformed to prenex normal form (PNF) in

which there is a series of quantifiers (prefix) in front of any first order
formula without quantifiers (matrix)
  If cnf of matrix contains a clause

α1∨ … ∨
αm∨ α and each αi is an
atom, and prefix contains ∀x1,…,∀xn where x1,…,xn are variables in
matrix, then the clause can be represented as the definite rule

∀x1,…,∀xn α1 , … , αm → α
  A query to a definite clause program is a PNF formula

∃x1 … ∃xn F where F is a conjunction of atoms and x1 …
xn are the variables in F

Recap on Lecture 2
  Programming with definite clauses involves

unifying an atom in the query with the head
of a rule
  We find the most general unifier (mgu) of
the query atom and rule head
  Replace the query atom by the rule body
and apply the mgu to the new query

Most general unifiers
  Two formulae that unify might have many different unifying substitutions :

1) m(x,y) and m(a,z) are unified by S1 = { (x/a), (y/z) }
m(a,z)
2) m(x,y) and m(a,z) are unified by S2 = { (x/a),(y/b),(z/b) }
m(a,b)
Formally:
S1 is the mgu of F1 and F2 if and only if
for all other unifiers S2 there is some substitution S3
such that S2( {F1, F2 } ) = S3( S1( {F1, F2 }) )
For all other unifiers, e,g, S2 , for the result obtained by applying S2 …..
-  Applying mgu S1 to {m(x,y) , m(a,z)} gives m(a,z)
-  Applying S2 to {m(x,y) , m(a,z)} gives m(a,b)

From Definite Clause Programming to
Predicate Logic Programming

Recall the Exercise
  Before formally defining the definite clause programming

procedure let us do a couple more exercises
  Find an mgu for loves(y, x) and loves(x, heisenberg) ?

Solution
  Find an mgu for loves(y, x) and loves(x, heisenberg) ?

  Answer : S = { (y/ heisenberg) , (x/ heisenberg) }
  S applied to loves(y, x) gives

loves(heisenberg, heisenberg)
  S applied to loves(x, heisenberg) gives

loves(heisenberg, heisenberg)

Example
  Suppose we have the definite clause program
1.  → marrried(skylar,
2.  ∀x marrried(x,

heisenberg)

heisenberg) → loves(x, heisenberg)

  Let us look at the derivation tree for the query

? ∃y∃x loves(y, x)

Solution ?
1.  → marrried(skylar,
2.  ∀x marrried(x,

? ∃y∃x loves(y, x)

heisenberg)

heisenberg) → loves(x, heisenberg)
∀x marrried(x, heisenberg) → loves(x, heisenberg)
mgu = {(y/ heisenberg) , (x/ heisenberg)}

? married(heisenberg, heisenberg)

⇒  replace query atom with body of rule

and apply substitution

But intutively ? ∃y∃x loves(y, x) should be successful for
y/skylar and x/heisenberg. What’s going wrong here ?

Solution ?
? ∃y∃x loves(y, x)

∀x marrried(x, heisenberg) → loves(x, heisenberg

When giving mgu { (heisenberg) , (x/ heisenberg) } for
loves(y, x) and loves(x, heisenberg)
we are assuming x in loves(y, x) and loves(x, heisenberg) are
the same variable. But they are not ! They are distinct variables
⇒  so rename x in rule

Solution

? ∃y∃x loves(y, x)

? married(y, heis)

∀x marrried(x, heis) → loves(x, heis)
⇒ ∀z marrried(z, heis) → loves(z, heis)

mgu for loves(y, x) and loves(z, heis) is
{ (z/y) , (x/ heis) }
⇒  replace query atom with body of rule

marrried(z, heis) and apply substitution

Solution

? ∃y∃x loves(y, x)

? married(y, heis)

∀x marrried(x, heis) → loves(x, heis)
⇒ ∀z marrried(z, heis) → loves(z, heis)
→ marrried(skylar, heis)

Success with { (y/skylar) , (x/heis) }

Definite Clause Programming – Input
and Output
Let us formally define the programming procedure:
 Input: A program P of definite rules and a query

Q = ∃x1 … ∃xm α1 ∧…	∧	αn
Note that:
1)  As in the case of propositional definite rules we can
replace each ∧	by a comma
2)  We can drop ∃x1 … ∃xm implicitly assuming that all
variables in α1 ,…,αn are existentially quantified
 Output: If Q = α1 ∧…	∧	αn is logical consequence of P

then output Yes and substitution of variables in query Q, else
output No.

Definite Clause Programming - Method
1 Initialize Progress = true;
2 While Q ≠ empty and Progress = true do
Choose atom αi from Q = α1 ,…,αn ;
2.1 Choose rule β1,....,βm → γ (m ≥ 0) such that γ and αi unify
2.1.1 If necessary rename variables in β1,....,βm → γ
2.1.2 Find mgu S for αi and γ
2.1.3 replace αi (in Q) by β1,....,βm
2.1.4 apply S to new query α1…αi-1,β1…βm,αi+1 …αn
2.2 else Progress = false
3 If (Query = empty and Progress = true) then output Yes and
substitution of variables in query; else output No.

Definite Clause Programming - Method
1 Initialize Progress = true;
2 While Q ≠ empty and Progress = true do
Choose atom αi from Q = α1 ,…,αn ;
2.1 Choose rule β1,....,βm → γ (m ≥ 0) such that γ and αi unify
2.1.1 If necessary rename variables in β1,....,βm → γ
2.1.2 Find mgu S for αi and γ
2.1.3 replace αi (in Q) by β1,....,βm
2.1.4 apply S to new query α1…αi-1,β1…βm,αi+1 …αn
2.2 else Progress = false
3 If (Query = empty and Progress = true) then output Yes and
substitution of variables in query; else output No.

Definite Clause Programming - Method
2.1 Choose rule β1,....,βm → γ (m ≥ 0) such that γ and αi unify
2.1.1 If necessary rename variables in β1,....,βm → γ
If x is a variable in α1 ,…,αn and β1,....,βm → γ then
rename x in β1,....,βm → γ :
replace x in β1,....,βm → γ by a new variable
z, i.e., a variable z that does not appear in
α1 ,…,αn or β1,....,βm → γ

Example from last lecture
→ loves(honeybunny, butch)
2.  → engaged(honeybunny, butch)
3.  ∀x∀y loves(x, y) , engaged(x, y) → marries(x, y)
1. 

? ∃z∃w marries(z, w)

Note that we can simply leave out :
•  the universal quantifiers before 3.
•  the ‘→’ before facts 1. and 2.
•  the existential quantifiers before query marries(z, w)
1.  loves(honeybunny, butch)
2.  engaged(honeybunny, butch)
3.  loves(x, y) , engaged(x, y) → marries(x, y)

? marries(z, w)

Example from last lecture
1.  loves(honeybunny, butch)
2.  engaged(honeybunny, butch)
3.  loves(x, y) , engaged(x, y) → marries(x, y)

? marries(z, w)

loves(x, y), engaged(x, y) → marries(x, y)
marries(z,w) unifies with marries(x,y)

with mgu { (x/z),(y/w) }
replace query atom with body of rule
and apply mgu

Example from last lecture
1.  loves(honeybunny, butch)
2.  engaged(honeybunny, butch)
3.  loves(x, y) , engaged(x, y) → marries(x, y)

? marries(z, w)

? loves(z, w), engaged(z, w)

loves(x, y), engaged(x, y) → marries (x, y)

Example from last lecture
1.  loves(honeybunny, butch)
2.  engaged(honeybunny, butch)
3.  loves(x, y) , engaged(x, y) → marries(x, y)

?

loves(x, y), engaged(x, y) → marries(x, y)

marries(z, w)

{ (x/z) , (y/w) }
? loves(z, w), engaged(z, w)

loves(honeybunny, butch)

{ (z/honneybunny) , (w/butch) }
? engaged(honeybunny,butch)

engaged(honeybunny, butch)

? marries(z, w) : Output yes with substitution

{ (z/honneybunny) , (w/butch) }

Another Example
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone

Another Example
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone
direct_flight(X,Y) → travel_between(X,Y)

Another Example
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone
direct_flight(X,Y), ticket(X,Y) → travel_between(X,Y)

Another Example
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone
direct_flight(X,Y), ticket(X,Y) → travel_between(X,Y)
buy_online(X,Y) → ticket(X,Y)

Another Example
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone
direct_flight(X,Y), ticket(X,Y) → travel_between(X,Y)
buy_online(X,Y) → ticket(X,Y)
buy_phone(X,Y) → ticket(X,Y)

Another Example
A ticket between X and Y is available if it can be bought online or
bought over the phone
How did we get to
buy_online(X,Y) → ticket(X,Y)
buy_phone(X,Y) → ticket(X,Y)
If we express directly in predicate logic we get:
∀x∀y buy_online(x, y) ∨ buy_phone(X,Y) → ticket(X,Y)

In the last lecture we saw examples where after transforming to PNF
we may need to apply distribution rules to get matrix of PNF formula into CNF

Another Example – Illustrating Or
A ticket between X and Y is available if it can be bought online or
bought over the phone
How did we get to
buy_online(X,Y) → ticket(X,Y)
buy_phone(X,Y) → ticket(X,Y)
∀x∀y buy_online(x, y) ∨ buy_phone(X,Y) → ticket(X,Y)
∀x∀y ¬ (buy_online(x, y) ∨ buy_phone(X,Y)) ∨ ticket(X,Y)
∀x∀y (¬ buy_online(x, y) ∧ ¬ buy_phone(X,Y)) ∨ ticket(X,Y)

= PNF

∀x∀y (¬ buy_online(x, y) ∨ ticket(X,Y)) ∧ (¬ buy_phone(X,Y) ∨ ticket(X,Y))
∀x∀y buy_online(x, y) → ticket(X,Y) ∀x∀y buy_phone(X,Y) → ticket(X,Y)

Representing And and Or
Express the following as a definite clause (predicate logic) program:
P if A and B and ….and Q
A, B,…, Q → P

Express the following as a definite clause (predicate logic) program:
P if A or B or ….or Q
A→P
B→P
:
Q→P

Another Example (adding facts)
Express the following as a definite clause (predicate logic) program:
One can travel between any two cities X and Y if there is a direct
flight from X to Y and there is a ticket available to travel from X to Y.
A ticket between X and Y is available if it can be bought online or
bought over the phone
Rules:
direct_flight(X,Y), ticket(X,Y) → travel_between(X,Y)
buy_online(Z,W) → ticket(Z,W)
buy_phone(V,U) → ticket(V,U)
Facts:
direct_flight(london,paris), direct_flight(paris,algiers)
buy_online(london,paris) , buy_phone(paris,algiers)

Queries without variables
?

t_b(lon, par)

Rules:

d_f(X,Y), t(X,Y) → t_b(X,Y)

{ (x/lon) , (y/par) }
? d_f(lon, par), t(lon, par)

d_f(X,Y), t(X,Y) → t_b(X,Y)
b_o(Z,W) → t(Z,W)
b_p(V,U) → t(V,U)
Facts:
d_f(lon,par), d_f(par,alg)
b_o(lon,par) , b_p(par,alg)

Remember that a query contains variables that are assumed
to be existentially quantified, but it can also contain constants

Choice Points and Backtracking

Choice points in derivation trees
?

t_b(lon, par)

Rules:

d_f(X,Y), t(X,Y) → t_b(X,Y)

{ (x/lon) , (y/par) }
d_f(lon, par)

? d_f(lon, par), t(lon, par)

? t(lon, par)

b_o(Z,W) → t(Z,W)

{ (z/lon) , (w/par) }

? b_o(lon, par)

d_f(X,Y), t(X,Y) → t_b(X,Y)
b_o(Z,W) → t(Z,W)
b_p(V,U) → t(V,U)
Facts:
d_f(lon,par), d_f(par,alg)
b_o(lon,par) , b_p(par,alg)

b_o(lon,par)

Output : yes

Choice point 1 : Usual to choose left most atom in query

Choice points in derivation trees
?

t_b(lon, par)

Rules:

d_f(X,Y), t(X,Y) → t_b(X,Y)

{ (x/lon) , (y/par) }
d_f(lon, par)

? d_f(lon, par), t(lon, par)

? t(lon, par)

b_o(Z,W) → t(Z,W)

{ (z/lon) , (w/par) }

? b_o(lon, par)

d_f(X,Y), t(X,Y) → t_b(X,Y)
b_o(Z,W) → t(Z,W)
b_p(V,U) → t(V,U)
Facts:
d_f(lon,par), d_f(par,alg)
b_o(lon,par) , b_p(par,alg)

b_o(lon,par)

Output : yes

Choice point 2 : Usual to choose first rule with matching head

Failed Derivations
?

t_b(par, alg)

Rules:

d_f(X,Y), t(X,Y) → t_b(X,Y)

{ (x/par) , (y/alg) }
? d_f(par, alg), t(par, alg)

? t(par, alg)

d_f(par, alg)
b_o(Z,W) → t(Z,W)

{ (z/par) , (w/alg) }

d_f(X,Y), t(X,Y) → t_b(X,Y)
b_o(Z,W) → t(Z,W)
b_p(V,U) → t(V,U)
Facts:
d_f(lon,par), d_f(par,alg)
b_o(lon,par) , b_p(par,alg)

? b_o(par, alg)
Output : no

Choosing first rule leads to failure, but we could have made a
choice that leads to success

Successful derivations
?

t_b(par, alg)

Rules:

d_f(X,Y), t(X,Y) → t_b(X,Y)

{ (x/par) , (y/alg) }
d_f(par, alg)

? d_f(par, alg), t(par, alg)

? t(par, alg)

b_p(Z,W) → t(Z,W)

{ (z/par) , (w/alg) }

d_f(X,Y), t(X,Y) → t_b(X,Y)
b_o(Z,W) → t(Z,W)
b_p(V,U) → t(V,U)
Facts:
d_f(lon,par), d_f(par,alg)
b_o(lon,par) , b_p(par,alg)

? b_p(par, alg)
Output : yes

Upon backtracking to last choice point, choosing second rule leads
to success

Showing all the derivation trees
and the order of generation
?

t_b(par, alg)

d_f(X,Y), t(X,Y) → t_b(X,Y)

? t_b(par, alg) d_f(X,Y),t(X,Y) → t_b(X,Y)

{ (x/par) ,(y/alg) }

{ (x/par) , (y/alg) }
? d_f(par, alg), t(par, alg) d_f(par, alg)
b_o(Z,W) → t(Z,W)
? t(par, alg)

{ (z/par) , (w/alg) }

? b_o(par, alg)
Output : no

? d_f(par, alg), t(par, alg) d_f(par, alg)

? t(par, alg)

b_p(Z,W) → t(Z,W)
{ (z/par) , (w/alg) }

? b_p(par, alg)
Output : yes

Backtrack to last choice point

Exercise
?

P(x,y)

Q(x,y), T(x,y), S(y)
Facts = Q(a,b)
Q(a,c)
Q(a,d)
T(a,c)

Show the derivation trees and the order in
Which they are generated if :
1.  The left query atom is always chosen
2.  The first listed rule or matching fact is chosen
3.  If failure then backtrack to last choice point and
and choose next listed rule or matching fact

T(a,d)
S(d)

→ P(x,y)

Negation as Failure

Negation as Failure
  Definite rules do not have negated atoms
  How then would we express the following ?

Someone is innocent if they are not guilty
  The following is not a definite rule

¬ guilty(x) → innocent(x)
and furthermore definite rules cannot have negated atoms as
their heads (no rule can have ¬ guilty(x) as its head )

Negation as Failure
  Definite rules do not have negated atoms
  How then would we express the following ?

Someone is innocent if they are not guilty
  The following is not a definite rule

¬ guilty(x) → innocent(x)
and furthermore definite rules cannot have negated atoms as
their heads (no rule can have ¬ guilty(x) as its head )
  But intuitively someone is innocent if it is not known (it cannot
be shown/proved) that he is guilty
  So why not say that ¬ guilty(x) follows from a program if
query ? guilty(x) fails

The closed world assumption
  This is a different kind of negation for which we use symbol

‘not’
  Remember that for ¬ α to be true we need to explicitly prove ¬α
( e.g., ¬ exists(god) , ¬ guilty(julan-assange) )
For this reason, ¬ is sometimes called strict negation.
  For ‘ not α ‘ to be true (i.e., for α ‘ to be false) we need to show

that α is not known to be true. That is to say :
every attempt to prove α fails, i.e., there is no successful
derivation tree for α.
  The closed world assumption (CWA) is the presumption that

what can currently not be shown to be true is false.

Example
?

P(x,y)

Q(x1,y1), not T(x1,y1), S(y1)

? Q(x,y), not T(x,y), S(y)

? S(b)

Q(x,y), not T(x,y), S(y)

Q(a,b)

? not T(a,b), S(b)

→ P(x1,y1)

Q(a,b)
? T(a,b)

S(b)

Output : yes x / a , y / b

Q(a,c)

T(a,d)

Q(a,d)

S(b)

S(d)

→ P(x,y)

Example
?

P(x,y)

Q(x1,y1), not T(x1,y1), S(y1)

? Q(x,y), not T(x,y), S(y)

? not T(a,c), S(c)

? S(c)
Output : no

→ P(x1,y1)
Q(x,y), not T(x,y), S(y)

Q(a,c)

Q(a,c)
? T(a,c)

Q(a,b)

T(a,d)

Q(a,d)

S(b)

S(d)

→ P(x,y)

Example
?

P(x,y)

Q(x1,y1), not T(x1,y1), S(y1)

? Q(x,y), not T(x,y), S(y)

? not T(a,d), S(d)

Output : no

→ P(x1,y1)
Q(x,y), not T(x,y), S(y)

Q(a,d)

Q(a,d)
? T(a,d)

Q(a,b)

T(a,d)

Q(a,c)

S(b)

S(d)

→ P(x,y)

The closed world assumption
 For ‘ not α ‘ to be true (i.e., for α ‘ to be false) we need to show

that α is not known to be true. That is to say :
every attempt to prove α fails, i.e., there is no successful
derivation tree for α.

Example
?

Q(x1,y1), not T(x1,y1) → P(x1,y1)

P(a,b)

Q(x,y), not T(x,y) → P(x,y)
? Q(a,b), not T(a,b)

G(v,w) → T(v,w)

Q(a,b)

H(v,w) → T(v,w)
? not T(a,b)

Q(a,b)
? T(a,b)
G(a,b)

Output : yes

G(v,w) → T(v,w)
? T(a,b)
H(a,b)

H(v,w) → T(v,w)

From Definite Clause Programming to
Predicate Logic Programming
  Predicate logic programming = Definite Clause Programming +

1) Control (procedural) features with selection of
leftmost query atom and topmost program rule or fact

From Definite Clause Programming to
Predicate Logic Programming - Method
1 Initialize Progress = true;
2 While Q ≠ empty and Progress = true do

Choose atom α1 from Q = α1 ,…,αn ;
2.1 Choose top rule β1,....,βm → γ (m ≥ 0) such that γ and αi unify
2.1.1 If necessary rename variables in β1,....,βm → γ
2.1.2 Find mgu S for αi and γ
2.1.3 replace αi (in Q) by β1,....,βm
2.1.4 apply S to new query α1…αi-1,β1…βm,αi+1 …αn
2.2 else Progress = false
3 If (Query = empty and Progress = true) then output Yes and
substitution of variables in query; else output No.

From Definite Clause Programming to
Predicate Logic Programming
  Predicate logic programming = Definite Clause Programming +

1) Control (procedural) features with selection of
leftmost query atom and topmost program rule or fact )
2) Backtracking to choice points
3) Negation as Failure (Closed World Assumption)
A predicate logic programming derivation includes all derivation trees
obtained on backtracking in order to prove query and all trees
attempting to prove α given a query “not α”

Example
Recall query ? P(x,y) to predicate logic program

Q(x,y), T(x,y), S(y)
Q(a,b)
Q(a,c)
Q(a,d)
T(a,c)

The predicate logic programming derivation
is all the derivation trees and the order in which
they are generated given that
1. The left query atom is always chosen
2. The first listed rule or matching fact is chosen
3. If failure then backtrack to last choice point and
and choose next listed rule or matching fact

T(a,d)
S(d)

→ P(x,y)

Tree 1
?

P(x,y)

Q(x1,y1), T(x1,y1), s(y1)

→ P(x1,y1)

mgu = { (x1/x), (y1/y) }
? Q(x,y), T(x,y), S(y)

Q(a,b)

Q(x,y), T(x,y), s(y)
Q(a,b)

? T(a,b), S(b)
Output : no

Backtrack to last choice point

Q(a,c)
Q(a,d)
T(a,c)
T(a,d)
S(d)

→ P(x,y)

Tree 2
?

Q(x1,y1), T(x1,y1), S(y1)

P(x,y)

? Q(x,y), T(x,y), S(y)

? T(a,c), S(c)

Q(a,c)
T(a,c)

→ P(x1,y1)
Q(x,y), T(x,y), s(y)
Q(a,b)
Q(a,c)
Q(a,d)
T(a,c)

? S(c)

T(a,d)
Output : no

Backtrack to last choice point

S(d)

→ P(x,y)

Tree 3
?

Q(x1,y1), T(x1,y1), S(y1)

P(x,y)

? Q(x,y), T(x,y), S(y)

? T(a,d), S(d)
? S(d)

Q(a,d)
T(a,d)

→ P(x1,y1)
Q(x,y), T(x,y), s(y)
Q(a,b)
Q(a,c)
Q(a,d)

S(d)

T(a,c)
T(a,d)

Output : yes x / a , y / d

S(d)

→ P(x,y)

Predicate Logic Programming
Derivation
?

Q(x1,y1), not T(x1,y1) → P(x1,y1)

P(a,b)

? Q(a,b), not T(a,b)

? not T(a,b)

Q(a,b)

Main Tree

? T(a,b)
G(a,b)

Output : yes

G(v,w) → T(v,w)
? T(a,b)
H(a,b)

H(v,w) → T(v,w)

Predicate Logic Programming
Derivation
?

Q(x1,y1), not T(x1,y1) → P(x1,y1)

P(a,b)

? Q(a,b), not T(a,b)

? not T(a,b)

Q(a,b)
Sub-Tree 1

? T(a,b)
G(a,b)

Output : yes

G(v,w) → T(v,w)
? T(a,b)
H(a,b)

H(v,w) → T(v,w)

Predicate Logic Programming
Derivation
?

Q(x1,y1), not T(x1,y1) → P(x1,y1)

P(a,b)

? Q(a,b), not T(a,b)

? not T(a,b)

Q(a,b)

? T(a,b)
G(a,b)

Output : yes

G(v,w) → T(v,w)
Sub-Tree 2

? T(a,b)
H(a,b)

H(v,w) → T(v,w)

Recursion

Predicate Logic Programming
Example of Recursion
Specify the following as a predicate logic program:
One can travel from city X to Y if there is a direct flight from
X to Y, or one can travel from city X to Y if one can get a
direct flight from X to Z, and then travel from city Z to Y

Predicate Logic Programming
Example of Recursion
Specify the following as a predicate logic program:
One can travel from city X to Y if there is a direct flight from
X to Y, or one can travel from city X to Y if one can get a
direct flight from X to Z, and one can travel from Z to Y
  direct_flight(x,y) → travel_from(x,y)

Predicate Logic Programming
Example of Recursion
Specify the following as a predicate logic program:
One can travel from city X to Y if there is a direct flight from
X to Y, or one can travel from city X to Y if one can get a
direct flight from X to Z, and one can travel from Z to Y
  direct_flight(x,y) → travel_from(x,y)
  direct_flight(x,z) , travel_from(z,y) → travel_from(x,y)

Predicate Logic Programming:
Example
1) direct_flight(x,y) → travel_from(x,y)
2) direct_flight(x,z) , travel_from(z,y) → travel_from(x,y)
3) direct_flight(london, paris)
4) direct_flight(paris, algiers)
? t_f(lon,alg)
? t_f(lon,alg)

2)

1)
? di_f(lon,z), t_f(z,alg) 3)

? di_f(lon,alg)

backtrack =>

• 

? t_f(paris,alg)

1)

? di_f(paris,alg)

4)

Recursion
1) direct_flight(x,y) → travel_from(x,y)
2) direct_flight(x,z) , travel_from(z,y) → travel_from(x,y)
3) direct_flight(london, paris)
4) direct_flight(paris, algiers)
? t_f(lon,alg)

2)

? di_f(lon,z), t_f(z,alg) 3)
• 

Recursive call to ‘travel_from’

? t_f(paris,alg)

1)

? di_f(paris,alg)

4)

Recursion
  Recursion is the process of repeating items in a self-similar way.
  Recursion in computer science is a method where the solution to a

problem depends on solutions to smaller instances of the same
problem
  The smallest instance of the solution to the problem of whether one

can travel from X to Y is when there is a direct flight from X to Y (the
base case)
1) direct_flight(x,y) → travel_from(x,y)
  Otherwise, in the general case, the solution to the problem of

whether one can travel from X to Y depends on a smaller instance of
the same problem – whether can one travel from Z to Y – given that
there is a direct flight from X to Z
2) direct_flight(x,z) , travel_from(z,y) → travel_from(x,y)

Exercise
1) direct_flight(x,y) → travel_from(x,y)
2) direct_flight(x,z) , travel_from(z,y) → travel_from(x,y)
3) direct_flight(london, paris)
4) direct_flight(paris, algiers)
5) direct_flight(algiers,oran)

Draw only the successful derivation tree for the query:
? travel_from(london,oran)

One more exercise
Specify the following as a predicate logic program:
hillary plans to climb any mountain that: 1) is higher than any
mountain that he has climbed, and 2) he has not already climbed
Suppose hillary has climbed snowdon and k2, and
the mountain everest is of greater height than k2, and the
mountain k2 is of greater height than snowdon

Hint: first define recursive rules for higher(X,Y)
assuming binary facts of the form greater_height(X,Y).

Exercise
Draw a derivation tree for the query ? plan_climb(hillary,k2)

Exercise
Draw a successful derivation tree for the query
? plan_climb(hillary,everest)
that makes use of the general case of the recursive program for
higher(X,Y)

The End
•  And that’s it !
•  Next week Revision Lecture

